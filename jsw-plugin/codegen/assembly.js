

export function generateAS(functions, structs, globals, lambdas) {
    let code = `// Auto-generated by jsw
@external("env", "consoleLog")
declare function __consoleLogString(s: string): void;

function consoleLog<T>(val: T): void {
  if (isString<T>()) {
    __consoleLogString(changetype<string>(val));
  } else {
    __consoleLogString(val.toString());
  }
}

class Closure {
  index: u32;
  env: usize;
  type: u32; // 0 = Wasm, 1 = JS
  constructor(index: u32, env: usize, type: u32) {
    this.index = index;
    this.env = env;
    this.type = type;
  }
}
export function __new_Closure(index: u32, env: usize, type: u32): Closure { return new Closure(index, env, type); }
export function __get_Closure_index(c: Closure): u32 { return c.index; }
export function __get_Closure_env(c: Closure): usize { return c.env; }
export function __get_Closure_type(c: Closure): u32 { return c.type; }

`;

    const arrayTypes = new Set();

    const mapType = (t) => {
        if (t.startsWith('Closure<')) return 'Closure';
        if (t.endsWith('[]')) {
            const elem = t.slice(0, -2);
            const mappedElem = mapType(elem);
            const asType = `Array<${mappedElem}>`;
            arrayTypes.add(asType);
            return asType;
        }
        return t;
    };

    // Generate Globals
    if (globals) {
        globals.forEach(g => {
            code += `export var ${g.name}: ${g.type} = ${g.value};\n`;
        });
    }

    // Generate Structs
    if (structs) {
        for (const struct of structs) {
            code += `class ${struct.name} {\n`;
            for (const field of struct.fields) {
                const asType = mapType(field.type);
                let init = '';
                if (asType === 'f64' || asType === 'i32' || asType === 'u32') init = ' = 0';
                else if (asType === 'bool') init = ' = false';
                else if (asType === 'string') init = ' = ""';
                else if (asType.startsWith('Array<')) init = ` = new ${asType}(0)`;
                else if (asType === 'Closure') init = ` = new Closure(0, 0, 0)`;
                else init = ` = new ${asType}()`; // Structs

                code += `  ${field.name}: ${asType}${init};\n`;
            }

            if (struct.constructorParams && struct.constructorParams.length > 0) {
                const params = struct.constructorParams.map(p => {
                    const asType = mapType(p.type);
                    let defaultVal = '0';
                    if (asType === 'bool') defaultVal = 'false';
                    else if (asType === 'string') defaultVal = '""';
                    return `${p.name}: ${asType} = ${defaultVal}`;
                }).join(', ');
                code += `  constructor(${params}) {\n`;
                struct.constructorParams.forEach(p => {
                    code += `    this.${p.name} = ${p.name};\n`;
                });
                code += `  }\n`;
            }

            code += `}\n\n`;

            // Generate helpers for marshalling
            code += `export function __new_${struct.name}(): ${struct.name} { return new ${struct.name}(); }\n`;
            code += `export function __idof_${struct.name}(): u32 { return idof<${struct.name}>(); }\n`;
            
            for (const field of struct.fields) {
                const asType = mapType(field.type);
                code += `export function __set_${struct.name}_${field.name}(obj: ${struct.name}, val: ${asType}): void { obj.${field.name} = val; }\n`;
                code += `export function __get_${struct.name}_${field.name}(obj: ${struct.name}): ${asType} { return obj.${field.name}; }\n`;
            }
            code += `\n`;
        }
    }

    // Generate Lambdas
    if (lambdas) {
        lambdas.forEach(l => {
            const params = l.params.map(p => `${p.name}: ${mapType(p.type)}`).join(', ');
            const returnType = mapType(l.returnType);
            code += `export function ${l.name}(${params}): ${returnType} ${l.body}\n\n`;
        });
    }

    for (const func of functions) {
        // Generate external declarations for callbacks
        for (const p of func.params) {
            if (p.isCallback) {
                const sig = p.callbackSignature;
                const args = ['fnIndex: u32', ...sig.params.map((t, i) => `arg${i}: ${mapType(t)}`)].join(', ');
                const ret = mapType(sig.returnType);
                code += `@external("env", "__invoke_${p.name}")\n`;
                code += `declare function __invoke_${p.name}(${args}): ${ret};\n\n`;
            }
        }

        const params = func.params.map(p => `${p.name}: ${mapType(p.type)}`).join(', ');
        const returnType = mapType(func.returnType);
        
        let body = func.body;
        
        // No more manual replacements for Closure/Lambda returns
        // The parser now generates `new Closure(...)`
        
        code += `export function ${func.name}(${params}): ${returnType} ${body}\n\n`;
    }

    // Generate ID helpers for arrays
    for (const type of arrayTypes) {
        const safeName = type.replace(/[<>]/g, '_');
        code += `export function __idof_${safeName}(): u32 { return idof<${type}>(); }\n`;
    }

    return code;
}
